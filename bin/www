#!/usr/bin/env node
/**
 * Module dependencies.
 */
const serverOptions = require("../config").serverOptions;
const defaultEyeOptions = require("../config").defaultEyeOptions;
const program = require('commander');
const fu = require('../server/persistence');
const debug = require('debug')('the-hydra-eye-js:server');
const pjson = require('../package.json');
const fs = require('fs-extra')
const path = require('path');
const dsl = require('../server/dsl_v1');

program
    .version(pjson.version, '-v, --version')
    .option('-e, --eye <eye_path>', 'Path to the eye reasoner', defaultEyeOptions.eyePath)
    .option('--verbose', 'verbose mode');

function setOptions(options, absolutePath) {
    defaultEyeOptions.eyePath = program.eye;
    serverOptions.port = options.port;
    serverOptions.appEntrypoint = options.app;
    serverOptions.workSpacePath = absolutePath;
    serverOptions.verbose = program.verbose;
}

program
    .command('serve <directory>')
    .description('start a server')
    .option('-a, --app <app_entrypoint>', 'API entrypoint', serverOptions.appEntrypoint)
    .option('-p, --port <port>', 'server port', serverOptions.port)
    .action(function(directory, options){
        let absolutePath = path.resolve(directory);
        // Check directory
        if (fu.exists(absolutePath)){
            console.log('Starting Hydra eye server\n');
            setOptions(options, absolutePath);
            console.log('Workspace: [%s]\nRoot :%s',serverOptions.workSpacePath, JSON.stringify(fu.readDir(serverOptions.workSpacePath), 2));
            serve();
        } else {
            console.error("Cannot open directory [%s]",directory);
        }
    });

program
    .command('list <directory>')
    .description('describes the workspace')
    .action(function(directory, options){
        let absolutePath = path.resolve(directory);
        // Check directory
        if (fu.exists(absolutePath)){
            console.log('Listing services\n');
            setOptions(options, absolutePath);
            validateWorkspace(absolutePath);
        } else {
            console.error("Cannot open directory [%s]",directory);
        }
    });


program
    .command('*')
    .action(function(command){
        console.log('command %s not recognized (hes --help)',command);
    });

if (!process.argv.slice(2).length) {
    program.outputHelp();
}

program.parse(process.argv);

// Only call when the config is set up
function serve(){

    let app = require('../server/app');
    let http = require('http');
    let reasoner = require('../server/reasoning');

    reasoner.invokeEye(defaultEyeOptions.eyePath + " --version")
        .then(function (result) {
            console.log(result.stderr);

            /**
             * Get port from environment and store in Express.
             */
            let port = normalizePort(serverOptions.port);
            app.set('port', port);

            /**
             * Create HTTP server.
             */

            let server = http.createServer(app);

            /**
             * Listen on provided port, on all network interfaces.
             */
            server.listen(port);
            server.on('error', onError);
            server.on('listening', onListening);


            /**
             * Normalize a port into a number, string, or false.
             */
            function normalizePort(val) {
                let port = parseInt(val, 10);
                if (isNaN(port)) {
                    // named pipe
                    return val;
                }
                if (port >= 0) {
                    // port number
                    return port;
                }
                return false;
            }

            /**
             * Event listener for HTTP server "error" event.
             */

            function onError(error) {
                if (error.syscall !== 'listen') {
                    throw error;
                }
                let bind = typeof port === 'string'
                    ? 'Pipe ' + port
                    : 'Port ' + port;
                // handle specific listen errors with friendly messages
                switch (error.code) {
                    case 'EACCES':
                        console.error(bind + ' requires elevated privileges');
                        process.exit(1);
                        break;
                    case 'EADDRINUSE':
                        console.error(bind + ' is already in use');
                        process.exit(1);
                        break;
                    default:
                        throw error;
                }
            }

            /**
             * Event listener for HTTP server "listening" event.
             */

            function onListening() {
                let addr = server.address();
                let bind = typeof addr === 'string'
                    ? 'pipe ' + addr
                    : 'port ' + addr.port;
                console.log('Listening on ' + bind);
            }

        })
        .catch(function (error) {
            console.error("ERROR: could not start the reasoner [EYE_PATH:%s]", defaultEyeOptions.eyePath);
            console.error(error)
        });

}

function validateWorkspace(absolutePath){
    const walkSync = (d) => {
        if (fs.statSync(d).isDirectory()) {
            return fs.readdirSync(d).map(f => walkSync(path.join(d, f)))
        } else {
            if (d.endsWith(serverOptions.indexFile)) {
                validate(d);
            } else {
                // remove-utf8-bom
                let contents = fs.readFileSync(d,{ encoding: 'utf8' });
                if (contents.charCodeAt(0) === 0xFEFF) {
                    contents = contents.substr(1);
                    console.log('utf8-bom detected at ' + d + ', being removed');
                    fs.outputFile(d, contents);
                }
            }
            return undefined
        }
    };
    walkSync(absolutePath);

    function validate(indexFile){
        console.log(indexFile);
        let index = fu.readJson(indexFile);
        if (index['hes:meta']){
            for (let operation of index['hes:meta']){
                console.log('\t'+operation['hes:name']);
                dsl.validateDeclaration(operation);
            }
        }
    }
}
